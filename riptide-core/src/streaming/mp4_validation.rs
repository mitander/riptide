//! MP4 validation and debugging utilities for streaming
//!
//! Provides tools to validate MP4 files generated by the remuxing pipeline,
//! catch metadata parsing issues, and ensure browser compatibility.

use std::io::{Read, Seek, SeekFrom};

use tracing::{debug, warn};

/// MP4 box types as 4-byte identifiers
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum Mp4BoxType {
    FileType,  // 'ftyp'
    Movie,     // 'moov'
    MediaData, // 'mdat'
    Free,      // 'free'
    Skip,      // 'skip'
    Unknown(u32),
}

impl Mp4BoxType {
    fn from_fourcc(fourcc: u32) -> Self {
        match fourcc {
            0x66747970 => Mp4BoxType::FileType,  // 'ftyp'
            0x6d6f6f76 => Mp4BoxType::Movie,     // 'moov'
            0x6d646174 => Mp4BoxType::MediaData, // 'mdat'
            0x66726565 => Mp4BoxType::Free,      // 'free'
            0x736b6970 => Mp4BoxType::Skip,      // 'skip'
            other => Mp4BoxType::Unknown(other),
        }
    }

    fn as_str(&self) -> &'static str {
        match self {
            Mp4BoxType::FileType => "ftyp",
            Mp4BoxType::Movie => "moov",
            Mp4BoxType::MediaData => "mdat",
            Mp4BoxType::Free => "free",
            Mp4BoxType::Skip => "skip",
            Mp4BoxType::Unknown(_) => "unknown",
        }
    }
}

/// MP4 box header information
#[derive(Debug, Clone)]
pub struct Mp4Box {
    pub box_type: Mp4BoxType,
    pub size: u64,
    pub offset: u64,
}

/// MP4 file structure analysis
#[derive(Debug)]
pub struct Mp4Structure {
    pub boxes: Vec<Mp4Box>,
    pub has_ftyp: bool,
    pub has_moov: bool,
    pub has_mdat: bool,
    pub moov_before_mdat: bool,
    pub total_size: u64,
}

impl Mp4Structure {
    /// Check if the MP4 structure is valid for streaming
    pub fn is_streaming_compatible(&self) -> bool {
        self.has_ftyp && self.has_moov && self.has_mdat && self.moov_before_mdat
    }

    /// Get a summary of structural issues
    pub fn issues(&self) -> Vec<String> {
        let mut issues = Vec::new();

        if !self.has_ftyp {
            issues.push("Missing 'ftyp' box (file type)".to_string());
        }

        if !self.has_moov {
            issues.push("Missing 'moov' box (movie metadata)".to_string());
        }

        if !self.has_mdat {
            issues.push("Missing 'mdat' box (media data)".to_string());
        }

        if self.has_moov && self.has_mdat && !self.moov_before_mdat {
            issues.push("'moov' box appears after 'mdat' box - not streaming-friendly".to_string());
        }

        issues
    }
}

/// Validates MP4 file structure from a byte stream
///
/// # Errors
/// - `Mp4ValidationError::IoError` - I/O error reading from the stream
/// - `Mp4ValidationError::InvalidStructure` - Invalid MP4 structure detected
/// - `Mp4ValidationError::BoxParsingError` - Error parsing MP4 box headers
pub fn validate_mp4_structure<R: Read + Seek>(
    reader: &mut R,
) -> Result<Mp4Structure, Mp4ValidationError> {
    let mut boxes = Vec::new();
    let mut has_ftyp = false;
    let mut has_moov = false;
    let mut has_mdat = false;
    let mut moov_offset = None;
    let mut mdat_offset = None;

    // Get total file size
    let total_size = reader
        .seek(SeekFrom::End(0))
        .map_err(Mp4ValidationError::IoError)?;
    reader
        .seek(SeekFrom::Start(0))
        .map_err(Mp4ValidationError::IoError)?;

    let mut current_offset = 0u64;

    while current_offset < total_size {
        let box_info = read_box_header(reader, current_offset)?;

        match box_info.box_type {
            Mp4BoxType::FileType => has_ftyp = true,
            Mp4BoxType::Movie => {
                has_moov = true;
                moov_offset = Some(current_offset);
            }
            Mp4BoxType::MediaData => {
                has_mdat = true;
                mdat_offset = Some(current_offset);
            }
            _ => {}
        }

        boxes.push(box_info.clone());
        current_offset += box_info.size;

        // Seek to next box
        reader
            .seek(SeekFrom::Start(current_offset))
            .map_err(Mp4ValidationError::IoError)?;
    }

    let moov_before_mdat = match (moov_offset, mdat_offset) {
        (Some(moov_pos), Some(mdat_pos)) => moov_pos < mdat_pos,
        _ => false,
    };

    Ok(Mp4Structure {
        boxes,
        has_ftyp,
        has_moov,
        has_mdat,
        moov_before_mdat,
        total_size,
    })
}

/// Reads MP4 box header (8 bytes: 4 bytes size + 4 bytes type)
fn read_box_header<R: Read + Seek>(
    reader: &mut R,
    offset: u64,
) -> Result<Mp4Box, Mp4ValidationError> {
    let mut header = [0u8; 8];
    reader
        .read_exact(&mut header)
        .map_err(Mp4ValidationError::IoError)?;

    let size = u32::from_be_bytes([header[0], header[1], header[2], header[3]]) as u64;
    let box_type_raw = u32::from_be_bytes([header[4], header[5], header[6], header[7]]);
    let box_type = Mp4BoxType::from_fourcc(box_type_raw);

    // Handle 64-bit size if needed
    let actual_size = if size == 1 {
        let mut size_64 = [0u8; 8];
        reader
            .read_exact(&mut size_64)
            .map_err(Mp4ValidationError::IoError)?;
        u64::from_be_bytes(size_64)
    } else {
        size
    };

    Ok(Mp4Box {
        box_type,
        size: actual_size,
        offset,
    })
}

/// Quick validation of MP4 header bytes
pub fn validate_mp4_header(data: &[u8]) -> bool {
    if data.len() < 8 {
        return false;
    }

    // Check for valid MP4 box header
    let box_type_raw = u32::from_be_bytes([data[4], data[5], data[6], data[7]]);
    let box_type = Mp4BoxType::from_fourcc(box_type_raw);

    matches!(box_type, Mp4BoxType::FileType)
}

/// Analyzes MP4 data for streaming compatibility issues
pub fn analyze_mp4_for_streaming(data: &[u8]) -> StreamingAnalysis {
    let mut analysis = StreamingAnalysis::default();

    if data.len() < 8 {
        analysis
            .issues
            .push("File too small to be valid MP4".to_string());
        return analysis;
    }

    // Check for proper ftyp box at start
    if !validate_mp4_header(data) {
        analysis
            .issues
            .push("Invalid or missing 'ftyp' box at file start".to_string());
    }

    // Look for moov box position
    if let Some(moov_pos) = find_box_position(data, Mp4BoxType::Movie) {
        analysis.moov_position = Some(moov_pos);

        if let Some(mdat_pos) = find_box_position(data, Mp4BoxType::MediaData) {
            analysis.mdat_position = Some(mdat_pos);

            if moov_pos > mdat_pos {
                analysis.issues.push(
                    "'moov' box after 'mdat' box - requires full download before playback"
                        .to_string(),
                );
            }
        }
    } else {
        analysis
            .issues
            .push("No 'moov' box found - file lacks metadata".to_string());
    }

    analysis.is_streaming_ready = analysis.issues.is_empty();
    analysis
}

/// Finds the position of a specific box type in MP4 data
fn find_box_position(data: &[u8], target_type: Mp4BoxType) -> Option<usize> {
    let mut offset = 0;

    while offset + 8 <= data.len() {
        let size = u32::from_be_bytes([
            data[offset],
            data[offset + 1],
            data[offset + 2],
            data[offset + 3],
        ]) as usize;
        let box_type_raw = u32::from_be_bytes([
            data[offset + 4],
            data[offset + 5],
            data[offset + 6],
            data[offset + 7],
        ]);
        let box_type = Mp4BoxType::from_fourcc(box_type_raw);

        if box_type == target_type {
            return Some(offset);
        }

        if size == 0 || size < 8 {
            break;
        }

        offset += size;
    }

    None
}

/// Analysis result for streaming compatibility
#[derive(Debug, Default, Clone)]
pub struct StreamingAnalysis {
    pub is_streaming_ready: bool,
    pub moov_position: Option<usize>,
    pub mdat_position: Option<usize>,
    pub issues: Vec<String>,
}

/// Errors that can occur during MP4 validation
#[derive(Debug, thiserror::Error)]
pub enum Mp4ValidationError {
    #[error("I/O error: {0}")]
    IoError(#[from] std::io::Error),

    #[error("Invalid MP4 structure: {0}")]
    InvalidStructure(String),

    #[error("Box parsing error: {0}")]
    BoxParsingError(String),
}

/// Test utility to validate remuxed MP4 output
pub fn test_remuxed_mp4_validity(mp4_data: &[u8]) -> Result<(), String> {
    let analysis = analyze_mp4_for_streaming(mp4_data);

    if !analysis.is_streaming_ready {
        let issues = analysis.issues.join(", ");
        return Err(format!("MP4 not streaming-ready: {issues}"));
    }

    debug!(
        "MP4 validation passed - {} bytes, streaming-ready",
        mp4_data.len()
    );
    Ok(())
}

/// Debug utility to log MP4 structure details
pub fn debug_mp4_structure(data: &[u8], max_boxes: usize) {
    debug!(
        "MP4 Structure Analysis (first {} bytes):",
        data.len().min(1024)
    );

    let mut offset = 0;
    let mut box_count = 0;

    while offset + 8 <= data.len() && box_count < max_boxes {
        let size = u32::from_be_bytes([
            data[offset],
            data[offset + 1],
            data[offset + 2],
            data[offset + 3],
        ]) as usize;
        let box_type_raw = u32::from_be_bytes([
            data[offset + 4],
            data[offset + 5],
            data[offset + 6],
            data[offset + 7],
        ]);
        let box_type = Mp4BoxType::from_fourcc(box_type_raw);

        debug!(
            "  Box {}: type={}, size={}, offset={}",
            box_count + 1,
            box_type.as_str(),
            size,
            offset
        );

        if size == 0 || size < 8 {
            warn!("  Invalid box size {} at offset {}", size, offset);
            break;
        }

        offset += size;
        box_count += 1;
    }

    if box_count == max_boxes && offset < data.len() {
        debug!("  ... (truncated at {} boxes)", max_boxes);
    }
}

#[cfg(test)]
mod tests {
    use std::io::Cursor;

    use super::*;

    #[test]
    fn test_mp4_box_type_parsing() {
        assert_eq!(Mp4BoxType::from_fourcc(0x66747970), Mp4BoxType::FileType);
        assert_eq!(Mp4BoxType::from_fourcc(0x6d6f6f76), Mp4BoxType::Movie);
        assert_eq!(Mp4BoxType::from_fourcc(0x6d646174), Mp4BoxType::MediaData);
    }

    #[test]
    fn test_mp4_header_validation() {
        // Valid ftyp box header
        let valid_header = [0x00, 0x00, 0x00, 0x20, 0x66, 0x74, 0x79, 0x70];
        assert!(validate_mp4_header(&valid_header));

        // Invalid header
        let invalid_header = [0x00, 0x00, 0x00, 0x20, 0x69, 0x6e, 0x76, 0x6c];
        assert!(!validate_mp4_header(&invalid_header));

        // Too short
        let short_header = [0x00, 0x00, 0x00];
        assert!(!validate_mp4_header(&short_header));
    }

    #[test]
    fn test_streaming_analysis() {
        // Create minimal valid MP4 structure
        let mut mp4_data = Vec::new();

        // ftyp box
        mp4_data.extend_from_slice(&[0x00, 0x00, 0x00, 0x20]); // size
        mp4_data.extend_from_slice(&[0x66, 0x74, 0x79, 0x70]); // 'ftyp'
        mp4_data.extend_from_slice(&[0x00; 24]); // ftyp data

        // moov box
        mp4_data.extend_from_slice(&[0x00, 0x00, 0x00, 0x08]); // size
        mp4_data.extend_from_slice(&[0x6d, 0x6f, 0x6f, 0x76]); // 'moov'

        // mdat box
        mp4_data.extend_from_slice(&[0x00, 0x00, 0x00, 0x08]); // size
        mp4_data.extend_from_slice(&[0x6d, 0x64, 0x61, 0x74]); // 'mdat'

        let analysis = analyze_mp4_for_streaming(&mp4_data);
        assert!(analysis.is_streaming_ready);
        assert!(analysis.moov_position.is_some());
        assert!(analysis.mdat_position.is_some());
        assert!(analysis.issues.is_empty());
    }

    #[test]
    fn test_moov_after_mdat_detection() {
        // Create MP4 with moov after mdat (not streaming-friendly)
        let mut mp4_data = Vec::new();

        // ftyp box
        mp4_data.extend_from_slice(&[0x00, 0x00, 0x00, 0x20]); // size
        mp4_data.extend_from_slice(&[0x66, 0x74, 0x79, 0x70]); // 'ftyp'
        mp4_data.extend_from_slice(&[0x00; 24]); // ftyp data

        // mdat box first
        mp4_data.extend_from_slice(&[0x00, 0x00, 0x00, 0x08]); // size
        mp4_data.extend_from_slice(&[0x6d, 0x64, 0x61, 0x74]); // 'mdat'

        // moov box after
        mp4_data.extend_from_slice(&[0x00, 0x00, 0x00, 0x08]); // size
        mp4_data.extend_from_slice(&[0x6d, 0x6f, 0x6f, 0x76]); // 'moov'

        let analysis = analyze_mp4_for_streaming(&mp4_data);
        assert!(!analysis.is_streaming_ready);
        assert!(
            analysis
                .issues
                .iter()
                .any(|issue| issue.contains("moov' box after 'mdat'"))
        );
    }

    #[test]
    fn test_validate_mp4_structure() {
        // Create valid MP4 structure
        let mut mp4_data = Vec::new();

        // ftyp box
        mp4_data.extend_from_slice(&[0x00, 0x00, 0x00, 0x20]); // size
        mp4_data.extend_from_slice(&[0x66, 0x74, 0x79, 0x70]); // 'ftyp'
        mp4_data.extend_from_slice(&[0x00; 24]); // ftyp data

        // moov box
        mp4_data.extend_from_slice(&[0x00, 0x00, 0x00, 0x08]); // size
        mp4_data.extend_from_slice(&[0x6d, 0x6f, 0x6f, 0x76]); // 'moov'

        // mdat box
        mp4_data.extend_from_slice(&[0x00, 0x00, 0x00, 0x08]); // size
        mp4_data.extend_from_slice(&[0x6d, 0x64, 0x61, 0x74]); // 'mdat'

        let mut cursor = Cursor::new(&mp4_data);
        let structure = validate_mp4_structure(&mut cursor).unwrap();

        assert!(structure.is_streaming_compatible());
        assert_eq!(structure.boxes.len(), 3);
        assert!(structure.has_ftyp);
        assert!(structure.has_moov);
        assert!(structure.has_mdat);
        assert!(structure.moov_before_mdat);
    }

    #[test]
    fn test_remuxed_mp4_validity_function() {
        // Valid streaming MP4
        let mut valid_mp4 = Vec::new();
        valid_mp4.extend_from_slice(&[0x00, 0x00, 0x00, 0x20]); // size
        valid_mp4.extend_from_slice(&[0x66, 0x74, 0x79, 0x70]); // 'ftyp'
        valid_mp4.extend_from_slice(&[0x00; 24]); // ftyp data
        valid_mp4.extend_from_slice(&[0x00, 0x00, 0x00, 0x08]); // size
        valid_mp4.extend_from_slice(&[0x6d, 0x6f, 0x6f, 0x76]); // 'moov'
        valid_mp4.extend_from_slice(&[0x00, 0x00, 0x00, 0x08]); // size
        valid_mp4.extend_from_slice(&[0x6d, 0x64, 0x61, 0x74]); // 'mdat'

        assert!(test_remuxed_mp4_validity(&valid_mp4).is_ok());

        // Invalid MP4 (too small)
        let invalid_mp4 = vec![0x00, 0x01, 0x02];
        assert!(test_remuxed_mp4_validity(&invalid_mp4).is_err());
    }
}
